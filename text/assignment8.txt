1==>display:none-->the content in the tag not appear on the page at all.
    visibility:hidden-->the content will be hidden but the space allocated for it will be present on the page.

2==>Event
    The Event interface represents an event which takes place in the DOM.
    An event can be triggered by the user action 
    e.g. clicking the mouse button or tapping keyboard, or generated by APIs to represent the progress of an asynchronous task. 

    An event listener is a procedure in JavaScript that waits for an event to occur. 
    
3==>The onchange attribute fires the moment when the value of the element is changed.
    This event is similar to the oninput event. 
    The difference is that the oninput event occurs immediately after the value of an element has changed, 
    while onchange occurs when the element loses focus.
    ex:-in VS

4==>The destructuring assignment syntax is a JavaScript expression that makes it possible to unpack values from arrays, or properties from objects, into distinct variables.
    ex for arrays:                          
    let a, b, rest;
    [a, b] = [10, 20];

    console.log(a);
    expected output: 10

    console.log(b);
    expected output: 20

   ex for object:
let person2 = {
    name: "Avi",
    ph: 2343554,
    address: "tumur",
    email: "wgqwdet@nagga",
};

let { name, ph, address, email } = person2;
console.log(name);

5==>Spread syntax (...) allows an iterable, such as an array or string, to be expanded in places where zero or more arguments (for function calls) or elements (for array literals) are expected. 
     In an object literal, the spread syntax enumerates the properties of an object and adds the key-value pairs to the object being created.
     ex:const numbers = [1, 2, 3];
        console.log(sum(...numbers));
        expected output: 6
    The rest parameter syntax allows a function to accept an indefinite number of arguments as an array, providing a way to represent variadic functions in JavaScript.

Spread syntax looks exactly like rest syntax. 
In a way, spread syntax is the opposite of rest syntax. 
Spread syntax "expands" an array into its elements, while rest syntax collects multiple elements and "condenses" them into a single element.

8==>JSON.stringify()-->convert javascript object into json object.
    JSON.parse()-->convert json object to jvascript object.


ASSIGNMENT 9

1==>Promise
    The Promise object represents the eventual completion (or failure) of an asynchronous operation and its resulting value
    It allows you to associate handlers with an asynchronous action's eventual success value or failure reason. 
    This lets asynchronous methods return values like synchronous methods: instead of immediately returning the final value, 
    the asynchronous method returns a promise to supply the value at some point in the future.

   new Promise(function (resolve, reject) {
    if (10 > 4) {
        resolve("success");
    } else {
        reject("error");
    }
})
    .then((data) => {
        console.log(data);
    })
    .catch((err) => {
        console.log(err);
    });
console.log("ended");

2==>callback hell-> calling the  callbacks inside callbacks
                   we get a deeply nested doOperation() function, which is much harder to read and debug. 
                   This is sometimes called "callback hell" or the "pyramid of doom" (because the indentation looks like a pyramid on its side).

3==>Recursion is a process of calling itself. A function that calls itself is called a recursive function.
    def recurse(x):
    if x > 0:
       print(x)
       recurse(x - 1)

     recurse(10)

4==>The Fetch API provides a JavaScript interface for accessing and manipulating parts of the HTTP pipeline, such as requests and responses.
    It also provides a global fetch() method that provides an easy, logical way to fetch resources asynchronously across the network.
    Fetch provides a better alternative that can be easily used by other technologies such as Service Workers.

   Get():-
   The get syntax binds an object property to a function that will be called when that property is looked up.
   ex:
  const obj = {
  log: ['a', 'b', 'c'],
  get latest() {
    return this.log[this.log.length - 1];
  }
};

console.log(obj.latest);
// expected output: "c"


5==>The this keyword refers to the current object in a method or constructor. 
    The most common use of the this keyword is to eliminate the confusion between class attributes and parameters with the same name

  ex:const test = {
  prop: 42,
  func: function() {
    return this.prop;
  },
};

console.log(test.func());
// expected output: 42


6==>The constructor method is a special method of a class for creating and initializing an object instance of that class.
  ex:
     class Polygon {
  constructor() {
    this.name = 'Polygon';
  }
}

const poly1 = new Polygon();

console.log(poly1.name);
// expected output: "Polygon"


7==>Classes are a template for creating objects. They encapsulate data with code to work on that data. 
    ex:
  class Rectangle {
  constructor(height, width) {
    this.height = height;
    this.width = width;
  }
}

11==> The set() method adds or updates an entry in a Map object with a specified key and a value.
      


    